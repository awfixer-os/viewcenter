<!DOCTYPE html>
<html>
  <head>
    <title>
      Test statechange event
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
  </head>
  <body>
    <script>
      const secondsToRender = 2;
      const sampleRate = 48000;

      let stateChangeCount = 0;
      let context;
      let contextState;

      const checkStateChange = (e) => {
        contextState = e.currentTarget.state;

        switch (stateChangeCount) {
          case 0:
            assert_equals(contextState, 'running', 'context.state');
            break;
          case 1:
            assert_equals(contextState, 'closed', 'context.state');
            break;
          default:
            assert_less_than_equal(
                stateChangeCount, 2, 'Number of state changes');
        }
        ++stateChangeCount;
      };

      const finalCheck = () => {
        // Final check that we got the right number of state changes and the
        // correct final state.
        assert_equals(stateChangeCount, 2, 'stateChangeCount');
        assert_equals(context.state, 'closed', 'After rendering context.state');
      };

      promise_test(t => {
        // Create an offline context with a source passing through a
        // convolver.  The convolver is just to waste some time.
        context = new OfflineAudioContext(
            1, secondsToRender * sampleRate, sampleRate);
        const buffer = createImpulseBuffer(context, sampleRate);

        // Use constructor form for source and pass buffer in options
        const source = new AudioBufferSourceNode(context, {buffer: buffer});
        const conv = new ConvolverNode(context, {
          buffer: buffer,
          disableNormalization: true,
        });

        source.connect(conv).connect(context.destination);
        source.start();

        context.onstatechange = (event) => checkStateChange(event);
        // Start rendering but do not await the promise here; original test
        // relied on scheduling and a timeout to perform final checks.
        context.startRendering();

        // Don't want to set an oncomplete for the context and don't want to
        // use the promise because the order of the state change event and
        // resolving the promise is not specified.  Thus, just wait for a
        // bit and then finish the test.  We assume the offline context runs
        // faster than realtime.
        return new Promise(resolve => {
          setTimeout(() => {
            finalCheck();
            resolve();
          }, secondsToRender * 1000);
        });
      }, 'test: Signaling of statechange event');
    </script>
  </body>
</html>
