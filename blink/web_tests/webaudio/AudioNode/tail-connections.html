<!doctype html>
<html>
  <head>
    <title>Test Reconnection of Tail-Processing Nodes</title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
  </head>
  <body>
    <script>
      // Run a test using the given test node that has a tail time.
      // |options| is a dictionary with the following members:
      //   testNodeName:        name of the node (used as a constructor)
      //   nodeOptions:         any options needed to create the node
      //   suspendTime:         Time at which oscillator should start
      //   tailProcessingTime:  Length of the tail of the node, in sec
      async function runTest(context, options) {
        // This test basically taken from the repro case in crbug.com/829767
        const osc = new OscillatorNode(context);
        const g0 = new GainNode(context);
        const g1 = new GainNode(context);
        const g2 = new GainNode(context);
        const g3 = new GainNode(context);
        const testNode =
            new window[options.testNodeName](context, options.nodeOptions);

        osc.connect(g0)
           .connect(g1)
           .connect(testNode)
           .connect(g2)
           .connect(g3)
           .connect(context.destination);

        // Disconnect the rest of the graph from g0.  This should place the
        // test node on the internal tail processing list.
        g0.disconnect();
        // Now reconnect g0 to the graph.  This should re-enable the test node
        // output and remove it from the tail list.
        g0.connect(g1);

        // Schedule suspension at suspendTime
        // Note: We avoid using `await` for suspend/resume because time in an
        // OfflineAudioContext does not advance until `startRendering()`
        // is called. Using `await` here would cause a deadlock,
        // since the suspend time is never reached.
        context.suspend(options.suspendTime).then(() => {
          // Validate suspend time occurs after tail time
          assert_greater_than_equal(
              options.suspendTime,
              options.tailProcessingTime,
              'Oscillator start time should be >= tail processing time');
          osc.start();
          context.resume();
        });

        const renderedBuffer = await context.startRendering();

        // Just check that the output isn't silence. If things are working
        // after reconnecting, there should be non-zero output.
        const outputData = renderedBuffer.getChannelData(0);
        const isSilent = outputData.every(sample => sample === 0);

        assert_false(
            isSilent,
            `Output of ${options.testNodeName} should not be all zeros`);
      }

      promise_test(async t => {
        const sampleRate = 16000;
        // These constants taken from dynamics_compress_kernel.{cc,h}.
        const preDelayFrames = 1024;
        const meteringReleaseTime = 0.325;
        const tailTime = 5 * meteringReleaseTime;
        const latencyTime = preDelayFrames / sampleRate;
        const tailProcessingTime = tailTime + latencyTime;

        // The DynamicsCompressorNode has a tail + latency time of ~1.68 s.
        // Use 3 s render duration to exceed it.
        const renderDuration = 3;

        const context = new OfflineAudioContext(
            1, renderDuration * sampleRate, sampleRate);

        await runTest(context, {
          testNodeName: 'DynamicsCompressorNode',
          nodeOptions: null,
          suspendTime: 2,
          tailProcessingTime: tailProcessingTime
        });
      }, 'Reconnect graph to DynamicsCompressor before end of tail');

      promise_test(async t => {
        const sampleRate = 16384;
        const renderDuration = 1;

        const context = new OfflineAudioContext(
            1, renderDuration * sampleRate, sampleRate);

        // Taken from BiquadFilter/tail-time-lowpass.html
        const filterOptions = {
          type: 'lowpass',
          Q: 40,
          frequency: sampleRate / 4
        };
        const tailProcessingTime = 2079.4 / sampleRate;

        await runTest(context, {
          testNodeName: 'BiquadFilterNode',
          nodeOptions: filterOptions,
          suspendTime: 0.5,
          tailProcessingTime: tailProcessingTime
        });
      }, 'Reconnect graph to Biquad before end of tail');
    </script>
  </body>
</html>
