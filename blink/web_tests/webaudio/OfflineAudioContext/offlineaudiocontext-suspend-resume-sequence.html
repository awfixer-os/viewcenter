<!DOCTYPE html>
<html>
  <head>
    <title>
      Test OfflineAudioContext.suspend() and resume() with timed sequence.
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
  </head>
  <body>
    <script>
      // The sample rate is multiple of the rendering quantum, so suspension
      // times fall into the render quantum boundary.
      const renderQuantum = 128;
      const sampleRate = renderQuantum * 100;
      const renderDuration = 2;

      // These numbers are in an arbitrary order, but not randomly generated
      // in runtime to avoid moving pieces. However, it is safe to arrange
      // them in a random order in runtime.
      //
      // Also these numbers are multiple of 0.25, so they are supposed to fall
      // in the render quantum boundary for easier and more intuitive
      // verification.
      const suspendTimes = [0.25, 0.75, 1.0, 0.5, 1.25, 0.0, 1.75];

      // Sorted ascending suspend times are our expected result.
      const expectedSuspendTimes = suspendTimes.slice().sort((a, b) => a - b);
      const actualSuspendTimes = [];

      promise_test(async () => {
        const context = new OfflineAudioContext(
            1, sampleRate * renderDuration, sampleRate);
        for (let i = 0; i < suspendTimes.length; i++) {
          // Schedule suspends in a random time order, but the actual
          // suspend must happen in ascending time order.
          scheduleSuspend(context, i, suspendTimes[i]);
        }

        await context.startRendering();
        verifyResult();
      }, 'resume() and suspend() with timed sequence');

      function scheduleSuspend(context, index, suspendTime) {
        try {
          context.suspend(suspendTime).then(() => {
            actualSuspendTimes.push(suspendTime);
            context.resume();
          });
        } catch (e) {
          assert_unreached(
              `Scheduling suspend #${index} at suspendTime second(s) ` +
                  `threw: ${e}`);
        }
      }

      function verifyResult() {
        for (let i = 0; i < actualSuspendTimes.length; i++) {
          const scheduledOrder = suspendTimes.indexOf(actualSuspendTimes[i]);
          const expectedOrder =
              expectedSuspendTimes.indexOf(actualSuspendTimes[i]);

          assert_equals(
              i,
              expectedOrder,
              `The resolution order of suspend #${scheduledOrder} is ` +
                  `${i} at ${suspendTimes[scheduledOrder].toFixed(2)} ` +
                  `second(s)`);
        }
      }
    </script>
  </body>
</html>
