<!DOCTYPE html>
<html>
  <head>
    <title>
      Test fftSize Changes Resetting AnalyserNode State
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
  </head>
  <body>
    <script>
      // Fairly arbitrary sample rate.
      const sampleRate = 24000;

      // Verify that setting the fftSize resets the memory for the FFT smoothing
      // operation.  Only a few of the possible variations are tested.

      promise_test(async () => {
        await testFFTSize({
          initialFFTSize: 128,
          finalFFTSize: 1024,
          errorThreshold: {relativeThreshold: 1.9455e-6}
        });
      }, 'fftSize 128 → 1024 resets state');

      promise_test(async () => {
        await testFFTSize({
          initialFFTSize: 512,
          finalFFTSize: 256,
          errorThreshold: {relativeThreshold: 1.8592e-6}
        });
      }, 'fftSize 512 → 256 resets state');

      async function testFFTSize(options) {
        const {initialFFTSize, finalFFTSize, errorThreshold} = options;

        // The duration is fairly arbitrary as long as it's long enough for the
        // FFT test.
        const context = new OfflineAudioContext(1, sampleRate, sampleRate);

        // Actual source doesn't matter but a sawtooth is a nice waveform with
        // lots of harmonic content.
        const osc = new OscillatorNode(context, {type: 'sawtooth'});

        // The analyser under test.
        const testAnalyser = new AnalyserNode(context, {
          fftSize: initialFFTSize,
        });

        // The reference analyser.  The fftSize is fixed to the desired value,
        // and we turn off smoothing so that we get the FFT of the current time
        // data.
        const refAnalyser = new AnalyserNode(context, {
          fftSize: finalFFTSize,
          smoothingTimeConstant: 0,
        });

        // Setup the graph and start the oscillator.
        osc.connect(testAnalyser).connect(context.destination);
        osc.connect(refAnalyser).connect(context.destination);

        osc.start();

        // Let the analyser smooth a few FFTs (rather arbitrary, but should be
        // more than one), then switch the size.
        const suspendFrame = 4 * initialFFTSize;
        const t1 = suspendFrame / context.sampleRate;

        // Second suspend is later to give the new fftSize time to take effect.
        const t2 = (suspendFrame + 1024) / context.sampleRate;


        context.suspend(t1).then(() => {
          testAnalyser.fftSize = finalFFTSize;
          return context.resume();
        });

        context.suspend(t2).then(() => {
          // Paused at t2 — capture both time-domain and frequency data.
          const testFFT = new Float32Array(testAnalyser.frequencyBinCount);
          const refFFT = new Float32Array(refAnalyser.frequencyBinCount);
          const testSignal = new Float32Array(testAnalyser.fftSize);
          const refSignal = new Float32Array(refAnalyser.fftSize);

          testAnalyser.getFloatTimeDomainData(testSignal);
          refAnalyser.getFloatTimeDomainData(refSignal);
          testAnalyser.getFloatFrequencyData(testFFT);
          refAnalyser.getFloatFrequencyData(refFFT);

          // Convert dB to linear scale.
          for (let i = 0; i < testFFT.length; ++i) {
            testFFT[i] = Math.pow(10, testFFT[i] / 20);
          }
          for (let i = 0; i < refFFT.length; ++i) {
            refFFT[i] = Math.pow(10, refFFT[i] / 20);
          }

          // Apply smoothing to the reference data to
          // match test analyser smoothing.
          const smoothing = 1 - testAnalyser.smoothingTimeConstant;
          for (let i = 0; i < refFFT.length; ++i) {
            refFFT[i] *= smoothing;
          }

          assert_array_equal_within_eps(
              testSignal,
              refSignal,
              {absoluteThreshold: 0},
              'Time data');

          assert_array_equal_within_eps(
              testFFT,
              refFFT,
              errorThreshold,
              'Linear FFT data after setting fftSize = ' + finalFFTSize);

          return context.resume();
        });

        // Start rendering after scheduling both suspends.
        return context.startRendering();
      }
    </script>
  </body>
</html>
