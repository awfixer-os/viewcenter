<!DOCTYPE html>
<html>
  <head>
    <title>
      Test Analyser.getByteTimeDomainData()
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
  </head>
  <body>
    <script>
      const sampleRate = 48000;
      // The size of the analyser frame.  Anything larger than 128 is ok, but
      // should be long enough to capture the peaks of the oscillator waveform.
      const fftSize = 256;
      // Number of frames to render.  Should be greater than the fftSize, but is
      // otherwise arbitrary.
      const renderFrames = 2 * fftSize;

      promise_test(async (t) => {
        const context = new OfflineAudioContext(1, renderFrames, sampleRate);

        // Create a sawtooth as the signal under test.  A sine wave or triangle
        // wave would probably also work.
        const src =
            new OscillatorNode(context, {type: 'sawtooth', frequency: 440});

        // Gain node to make sure the signal goes somewhat above 1, for testing
        // clipping.
        const gain = new GainNode(context, {gain: 1.5});

        // The analyser node to test
        const analyser = new AnalyserNode(context, { fftSize });

        // Connect the graph
        src.connect(gain);
        gain.connect(analyser);
        analyser.connect(context.destination);

        // Stop rendering after one analyser frame so we can grab the data.
        context.suspend(fftSize / sampleRate).then(() => {
          const floatData = new Float32Array(fftSize);
          const byteData = new Uint8Array(fftSize);

          analyser.getFloatTimeDomainData(floatData);
          analyser.getByteTimeDomainData(byteData);

          // Use the float data to compute the expected value for the byte
          // data.
          const expected = new Float32Array(fftSize);
          for (let k = 0; k < fftSize; ++k) {
            // It's important to do Math.fround to match the
            // single-precision float in the implementation!
            const value = Math.fround(128 * Math.fround(1 + floatData[k]));
            // Clip the result to lie in the range [0, 255].
            expected[k] = Math.floor(Math.min(255, Math.max(0, value)));
          }

          // Find the first index of the first sample that exceeds +1 or -1.
          // The test MUST have at least one such value.
          const indexMax = floatData.findIndex((x) => x > 1);
          const indexMin = floatData.findIndex((x) => x < -1);

          assert_greater_than_equal(
              indexMax, 0, 'Index of first sample greater than +1');
          assert_greater_than_equal(
              indexMin, 0, 'Index of first sample less than -1');

          // Verify explicitly that clipping happened correctly at the above
          // indices.
          assert_equals(
              byteData[indexMax],
              255,
              `Clip ${floatData[indexMax].toPrecision(6)}: ` +
                  `byteData[${indexMax}]`);
          assert_equals(
              byteData[indexMin],
              0,
              `Clip ${floatData[indexMin].toPrecision(6)}: ` +
                  `byteData[${indexMin}]`);

          // Verify that all other samples are computed correctly.
          assert_array_equals(byteData, expected, 'Byte data');
        }).then(() => context.resume());

        src.start();
        await context.startRendering();
      }, 'Analyser.getByteTimeDomainData() returns correct byte values ' +
          'including clipping behavior');
    </script>
  </body>
</html>
