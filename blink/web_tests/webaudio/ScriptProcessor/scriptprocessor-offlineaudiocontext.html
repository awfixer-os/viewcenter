<!DOCTYPE html>
<html>
<head>
  <title>
    ScriptProcessorNode on OfflineAudioContext
  </title>
  <script src="../../resources/testharness.js"></script>
  <script src="../../resources/testharnessreport.js"></script>
  <script src="../resources/audit-util.js"></script>
</head>
<body>
  <script>
    // Fill the output of script processor with a constant value.
    promise_test((t) => {
      const sampleRate = 44100;
      const scriptBufferSize = 256;
      const renderLength = 1;
      const PI = Math.fround(Math.PI);

      const context =
          new OfflineAudioContext(1, renderLength * sampleRate, sampleRate);

      const scriptNode =
          context.createScriptProcessor(scriptBufferSize, 1, 1);
      scriptNode.onaudioprocess = (event) => {
        const outputChannel = event.outputBuffer.getChannelData(0);
        outputChannel.fill(PI);
      };
      scriptNode.connect(context.destination);

      return context.startRendering().then((buffer) => {
        const channel = buffer.getChannelData(0);
        const initialDelay = channel.subarray(0, 2 * scriptBufferSize);
        const actualContent = channel.subarray(2 * scriptBufferSize);

        // There is the initial delay (2 x buffer size) which is silent.
        assert_array_equals(
            initialDelay,
            new Float32Array(initialDelay.length).fill(0),
            'The initial delay contains zeros.');

        // After the initial delay, we must get |PI|.
        assert_array_equals(
            actualContent,
            new Float32Array(actualContent.length).fill(PI),
            'The actual content contains ' + PI);
      });
    }, 'simple-output: ScriptProcessor fills output with constant');

    // Pass through an oscillator via a script processor. Sum with the
    // phase-inverted oscillator with the delayed start time. Verify the
    // rendered buffer is completely silent.
    promise_test((t) => {
      const sampleRate = 44100;
      const scriptBufferSize = 256;
      const renderLength = 1;

      const context =
          new OfflineAudioContext(1, renderLength * sampleRate, sampleRate);

      const osc1 = new OscillatorNode(context);
      const osc2 = new OscillatorNode(context);
      const inverter = new GainNode(context);
      const scriptNode =
          context.createScriptProcessor(scriptBufferSize, 1, 1);
      scriptNode.onaudioprocess = (event) => {
        const inputChannel = event.inputBuffer.getChannelData(0);
        const outputChannel = event.outputBuffer.getChannelData(0);
        outputChannel.set(inputChannel);
      };

      inverter.gain.value = -1;

      osc1.connect(inverter).connect(context.destination);
      osc2.connect(scriptNode).connect(context.destination);

      // The delayed start for |osc1|.
      osc1.start((2 * scriptBufferSize) / sampleRate);
      osc2.start();

      return context.startRendering().then((buffer) => {
        const channel = buffer.getChannelData(0);

        // The rendered buffer must be silent.
        assert_array_equals(
            channel,
            new Float32Array(channel.length).fill(0),
            'The rendered buffer is silent');
      });
    }, 'oscillator-output: ScriptProcessor pass-through cancels oscillator');
  </script>
</body>
</html>
