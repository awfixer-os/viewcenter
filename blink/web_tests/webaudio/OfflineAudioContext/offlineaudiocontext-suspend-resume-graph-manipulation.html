<!DOCTYPE html>

<html>
<head>
  <title>offlineaudiocontext-suspend-resume-graph-manipulation.html</title>
  <script src="../../resources/testharness.js"></script>
  <script src="../../resources/testharnessreport.js"></script>
  <script src="../resources/audit-util.js"></script>
</head>

<body>
  <script>
    promise_test(async (t) => {
      const renderQuantum = 128;
      const renderDuration = 3;

      // The sample rate is multiple of the rendering quantum, so suspension
      // times fall in to the render quantum boundary.
      const sampleRate = renderQuantum * 100;

      // Suspend at 1 second and activate the source node. The audio output
      // should be 1.0 from |suspendTime1| to the next suspension.
      const suspendTime1 = 1;

      // Suspend at 2 seconds and disconnect the node. The audio output should
      // be 0.0 from |suspendTime2| to the end.
      const suspendTime2 = 2;

      const context = new OfflineAudioContext(
          1, sampleRate * renderDuration, sampleRate);

      // Create a constant buffer of 1.0.
      const constantBuffer = createConstantBuffer(context, 1, 1.0);
      const constantSource = new AudioBufferSourceNode(
          context, { buffer: constantBuffer, loop: true });

      // The audio output from the beginning (0.0 second) to the first
      // suspend time should be 0.0 because there is no connection to the
      // destination.
      context.suspend(suspendTime1).then(() => {
        if (context.currentTime === suspendTime1) {
          assert_equals(
              context.currentTime * sampleRate,
              suspendTime1 * sampleRate,
              'Frame at which context is suspended');
        }
        constantSource.connect(context.destination);
        constantSource.start();
        context.resume();
      });

      context.suspend(suspendTime2).then(() => {
        if (context.currentTime === suspendTime2) {
          assert_equals(
              context.currentTime * sampleRate,
              suspendTime2 * sampleRate,
              'Context is suspended');
        }

        constantSource.disconnect();
        context.resume();
      });

      context.startRendering().then((buffer) => {
        verifyResult(
            buffer, sampleRate, suspendTime1, suspendTime2, renderDuration);
      });
    }, 'Synchronous graph manipulation with suspend() and resume()');

    function verifyResult(
        buffer, sampleRate, suspendTime1, suspendTime2, renderDuration) {
      const data = buffer.getChannelData(0);

      const suspendIndex1 = suspendTime1 * sampleRate;
      const suspendIndex2 = suspendTime2 * sampleRate;
      const endIndex = renderDuration * sampleRate;

      // Split the rendered buffer into 3 segments:
      // [0, suspendIndex1), [suspendIndex1, suspendIndex2),
      // [suspendIndex2, endIndex).
      const subarray0 = data.subarray(0, suspendIndex1);
      const subarray1 = data.subarray(suspendIndex1, suspendIndex2);
      const subarray2 = data.subarray(suspendIndex2, endIndex);

      // Each segment should contain a constant value of 0, 1 and 0
      // respectively.
      assert_array_equals(
          subarray0,
          new Float32Array(subarray0.length).fill(0),
          `Buffer frame [0, ${suspendIndex1}) should be 0.0`);
      assert_array_equals(
          subarray1,
          new Float32Array(subarray1.length).fill(1),
          `Buffer frame [${suspendIndex1}, ` +
          `${suspendIndex2}) should be 1.0`);
      assert_array_equals(
          subarray2,
          new Float32Array(subarray2.length).fill(0),
          `Buffer frame [${suspendIndex2}, ${endIndex}) should be 0.0`);
    }
  </script>
</body>
</html>
