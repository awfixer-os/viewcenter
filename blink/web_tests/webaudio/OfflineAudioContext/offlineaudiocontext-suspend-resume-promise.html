<!DOCTYPE html>
<html>
  <head>
    <title>
      offlineaudiocontext-suspend-resume-promise.html
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
    <script src="../resources/audit-util.js"></script>
  </head>
  <body>
    <script>
      let context;

      // The sample rate is multiple of the rendering quantum, so suspension
      // times fall in to the render quantum boundary.
      const renderQuantum = 128;

      const sampleRate = renderQuantum * 100;
      const renderDuration = 2;
      let scheduledSuspendTime = 0;

      // With the sample rate setting above, this ensures suspension time fall
      // in to the render quantum boundary.
      const suspendInterval = 0.25;

      function onSuspended() {
        if (context.state === 'suspended' &&
            context.currentTime === scheduledSuspendTime) {
          assert_true(
              context.state === 'suspended' &&
                  context.currentTime === scheduledSuspendTime,
              `Context suspended at ${scheduledSuspendTime} second(s)`);

          scheduledSuspendTime = context.currentTime + suspendInterval;

          // Scheduling a suspend before the render duration should pass.
          if (scheduledSuspendTime < renderDuration) {
            context.suspend(scheduledSuspendTime)
                .then(() => onSuspended())
                .catch(e => assert_unreached(
                    `Scheduling a new suspend threw ${e}`));
          }

          // Scheduling a suspend exactly at the render duration should be
          // rejected.
          if (scheduledSuspendTime === renderDuration) {
            context.suspend(scheduledSuspendTime)
                .then(() => {
                  assert_unreached(
                      `Scheduling at ${renderDuration} ` +
                          `seconds should be rejected`);
                })
                .catch(() => {
                  // expected rejection, nothing to do
                });
          }

          context.resume();
        }
      }

      promise_test(t => {
        context = new OfflineAudioContext(
            1, sampleRate * renderDuration, sampleRate);

        // Schedule the first suspension.
        try {
          context.suspend(scheduledSuspendTime)
              .then(() => onSuspended());
        } catch (e) {
          assert_unreached(`Scheduling a new suspend at ` +
              `${scheduledSuspendTime} second(s) threw ${e}`);
        }

        return context.startRendering().then(() => {
          assert_equals(context.state, 'closed', 'Promise context.state');
        });
      }, 'Promise resolution of resume() and suspend()');
    </script>
  </body>
</html>
